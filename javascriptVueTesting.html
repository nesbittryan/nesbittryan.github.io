<!DOCTYPE html>
<html>
<head>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #a07a2c;
}
</style>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/vue"></script>
<canvas id="canvas" width="800px" height="480px" style="float: left;"></canvas>
<br>
<div style="float: left; margin:10px;border-width:1px;border-color:black;border-style:dotted;">
<div style="margin:10px;">
  <h2>Ryans High School Zombie Bitt-r </h2>
  <div id="app">
    Enter your name:<br><input type="text" placeholder="Edit Me" v-model="user"></input>
    <button onclick="startGame()">Start Game</button>
    <h4>Leaderboard</h4>
    <ul>
      <li v-for="user in users">
        Score: {{user.score}} Name: {{user.fname}}
      </li>
    </ul>
  </div>
</div>
</div>
<script>

var app = new Vue({
  el: '#app',
  data: {
    user: '',
    users: [
      {score: '56783', fname: 'Ryan Nesbitt'}
    ],
    val: 0,
  }
})

var myGamePiece
var enemy = []
var bullets = []
var healthkits = []
var nukes = []
var score = 0
var myGameArea = {
    canvas : document.getElementById("canvas"),
    start : function() {
        this.canvas.width = 800;
        this.canvas.height = 480;
        this.context = this.canvas.getContext("2d");
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);
        window.addEventListener('mousemove', function (e) {
            myGameArea.x = e.pageX;
            myGameArea.y = e.pageY;
        })
        window.addEventListener('keydown', function (e) {
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = true;
        })
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },
    stop : function() {
        clearInterval(this.interval);
        app.users.push({score: score, fname: app.user});
        app.users.sort(function(a, b){return b - a});
    }
}

function startGame() {
  if (app.user == '') {
    alert("Please enter a username to play!!");
    return;
  }
  clearInterval(myGameArea.interval);
  score = 0;
  enemy = [];
  bullets = [];
  healthkits = [];
  nukes = [];
  myGamePiece = new component(30, 30, "black", 0, 0);
  myGameArea.start();
}

function everyinterval(n) {
    return ((myGameArea.frameNo / n) % 1 == 0);
}

function bullet(x, y, direction) {
  this.component = new component(4,4,"yellow", x, y);
  switch(direction) {
    case 0:
      this.xspeed = 0;
      this.yspeed = -5;
      break;
    case 1:
      this.xspeed = 5;
      this.yspeed = 0;
      break;
    case 2:
      this.xspeed = 0;
      this.yspeed = 5;
      break;
    case 3:
      this.xspeed = -5;
      this.yspeed = 0;
      break;
  }
}

function updateHealthbar () {
  ctx = myGameArea.context;
  width = myGamePiece.health * myGameArea.canvas.width / 10;
  ctx.fillStyle = 'green';
  ctx.fillRect(0, 0, width, 10);
  ctx.fillStyle = 'red';
  ctx.fillRect(width, 0, myGameArea.canvas.width - width, 10);
}

function updateScore() {
  ctx = myGameArea.context;
  ctx.font = "30px Arial";
  ctx.fillStyle = 'cyan'
  ctx.fillText('Score: ' +score, 5, 40);
}

function component(width, height, color, x, y) {
    this.width = width;
    this.height = height;
    this.health = 10;
    this.x = x;
    this.y = y;
    this.speedY = 0;
    this.speedX = 0;
    this.update = function(){
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    this.newPos = function() {
        this.x += this.speedX;
        this.y += this.speedY;
    }
    this.crashWith = function(otherobj) {
        var myleft = this.x;
        var myright = this.x + (this.width);
        var mytop = this.y;
        var mybottom = this.y + (this.height);
        var otherleft = otherobj.x;
        var otherright = otherobj.x + (otherobj.width);
        var othertop = otherobj.y;
        var otherbottom = otherobj.y + (otherobj.height);
        var crash = true;
        if ((mybottom < othertop) ||
               (mytop > otherbottom) ||
               (myright < otherleft) ||
               (myleft > otherright)) {
           crash = false;
        }
        return crash;
    }
}

function checkCollisions() {
  if (myGamePiece.health < 10) {
    for (i = 0; i < healthkits.length; i += 1) {
      if (myGamePiece.crashWith(healthkits[i])) {
        myGamePiece.health += 1;
        healthkits.splice(i, 1);
      }
    }
  }

  for (i = 0; i < nukes.length; i += 1) {
    if (myGamePiece.crashWith(nukes[i])) {
      score += enemy.length * 200;
      enemy = [];
      nukes.splice(i, 1);
    }
  }

  for (i = 0; i < enemy.length; i += 1) {
    if (myGamePiece.crashWith(enemy[i])) {
      myGamePiece.health--;
      updateHealthbar();
      if (myGamePiece.health == 0) {
        myGameArea.stop();
        return;
      }
      enemy.splice(i, 1);
    }
  }
  for (i = 0; i < bullets.length; i += 1) {
    if (bullets[i].component.crashWith(myGamePiece)) {
      myGamePiece.health--;
      updateHealthbar();
      bullets.splice(i, 1);
      if (myGamePiece.health == 0) {
        myGameArea.stop();
        return;
      }
      break;
    }
    for (j = 0; j < enemy.length; j += 1) {
      if (bullets[i].component.crashWith(enemy[j])) {
        enemy.splice(j, 1);
        bullets.splice(i, 1);
        score += 200;
        break;
      }
    }
  }
}

function processInput() {
  if (myGameArea.keys && myGameArea.keys[37]) {
    bullets.push(new bullet(myGamePiece.x - 5, myGamePiece.y + 15, 3))
  } else if (myGameArea.keys && myGameArea.keys[39]) {
    bullets.push(new bullet(myGamePiece.x + 35, myGamePiece.y + 15, 1))
  } else if (myGameArea.keys && myGameArea.keys[38]) {
    bullets.push(new bullet(myGamePiece.x + 15, myGamePiece.y - 5, 0))
  } else if (myGameArea.keys && myGameArea.keys[40]) {
    bullets.push(new bullet(myGamePiece.x + 15, myGamePiece.y + 35, 2))
  }

  myGameArea.keys = false
  myGameArea.keys[37] = false
  myGameArea.keys[38] = false
  myGameArea.keys[39] = false
  myGameArea.keys[40] = false;

  if (myGameArea.x && myGameArea.y) {
    if (myGameArea.x >= 20 && myGameArea.x <= myGameArea.canvas.width) {
      myGamePiece.x = myGameArea.x - 20;
    }
    if (myGameArea.y >= 20 && myGameArea.y <=  myGameArea.canvas.height) {
      myGamePiece.y = myGameArea.y - 20;
    }
  }
}

function ranx() {
  return Math.floor((Math.random() * myGameArea.canvas.width) + 1);
}

function rany() {
  return Math.floor((Math.random() * myGameArea.canvas.height) + 1);
}

function updateEntities() {
  interval = 1;
  if (score < 1000) {
    interval = 100;
  } else if (score < 5000) {
    interval = 60;
  } else if (score < 7500) {
    interval = 40;
  } else {
    interval = 20;
  }

  if (everyinterval(1000)) {
    x = ranx();
    y = rany();
    nukes.push(new component(10,10, "blue", x, y));
  }

  for (i = 0; i < nukes.length; i += 1) {
    nukes[i].update();
  }

  if (everyinterval(400)) {
    x = ranx();
    y = rany();
    healthkits.push(new component(25,25, "red", x, y));
  }

  for(i = 0; i < healthkits.length; i += 1) {
    healthkits[i].update();
  }

  if (myGameArea.frameNo == 1 || everyinterval(interval)) {
    monx = 0;
    mony = 0;
    do {
      monx = ranx();
      mony = rany();
    } while (Math.abs(myGamePiece.x - monx) < 100 && Math.abs(mony - myGamePiece.y) < 100);

    enemy.push(new component(20, 20, "green", monx, mony));
  }
  for (i = 0; i < enemy.length; i += 1) {
    if (enemy[i].x > myGamePiece.x) {
      enemy[i].x -= 2;
    } else if (enemy[i].x < myGamePiece.x) {
      enemy[i].x += 2;
    }
    if (enemy[i].y > myGamePiece.y) {
      enemy[i].y -= 2;
    } else if (enemy[i].y < myGamePiece.y) {
      enemy[i].y += 2;
    }

    enemy[i].update();
  }

  for (i = 0; i < bullets.length; i += 1) {
    bullets[i].component.y += bullets[i].yspeed
    bullets[i].component.x += bullets[i].xspeed
    bullets[i].component.update();
  }
}

function updateGameArea() {

  checkCollisions();

  myGameArea.clear();
  myGameArea.frameNo += 1;

  processInput();

  updateEntities();

  updateHealthbar();

  myGamePiece.newPos();
  myGamePiece.update();

  if (everyinterval(20)) {
    score += 1;
  }
  updateScore();
}

</script>
</body>
</html>
